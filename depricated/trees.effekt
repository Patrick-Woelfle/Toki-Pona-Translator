module trees // must be named same as the file!

import src/additionalLists


effect treeError(message: String): Unit


/// TODO: Switch Strings to Enumerations
type SyntaxTree {



  Empty();
  Leaf(label: String, value: List[String]);
  Value(value: String);
  Node1(label: String, first: SyntaxTree);
  Node2(label: String, first: SyntaxTree, second: SyntaxTree);

  Sentence(subjects: SyntaxTree, predicates: SyntaxTree);
  PhraseList(label: String, front: SyntaxTree, back: SyntaxTree);
  ObjectLeaf2(label: String, prep: String, head: String, modifiers: List[String]);
}

type PredicateTree {
  EmptyPredicate();
}


type Leaf3 {
  EmptyLeaf();
  Predicate(verbPhrase: Leaf3, objectPhrase: Leaf3, prepPhrase: Leaf3)
  ObjectLeaf(label: String, prep: String, head: String, modifiers: List[String]);
  VerbLeaf(label: String, preverbs: List[String], head: String, modifiers: List[String]);
}

def append2(sentence: SyntaxTree, node: SyntaxTree): SyntaxTree = {
  try {
    sentence match {
      case Sentence(subjectPhrases, predPhrases) => {
        node match {
          case ObjectLeaf2(label, prep, head, modifiers) => {
            if (label == "Subject Phrase") {
              return append2(subjectPhrases, node)
            } else if (label == "Object Phrase") {
              return append2(predPhrases, node)
            } else {
              do treeError("Expected Subject Phrase, Object Phrase or Verb Phrase, found ")
              return Empty()
            }
          }
          case _ => {
            do treeError("Expected Subject Phrase, Object Phrase or Verb Phrase"); 
            return Empty()
          }
        }
      }
      case PhraseList(label, front, back) => {
        front match {
          case Empty() => return PhraseList(label, node, back)
          case _ => {
            back match {
              case Empty() => return PhraseList(label, front, PhraseList(label, node, Empty()))
              case PhraseList(label, front, back) => return PhraseList(label, front, append2(back, node))
              case _ => {
                do treeError("Expected PhraseList, found ")
                return Empty()
             }
            }
          }
        }
      }
      case _ => <>
    }       
  } with treeError { t =>
    println(t)
    return Empty()
  }
}






def getfirst(node: SyntaxTree): SyntaxTree / treeError= {
  node match {
    case Leaf(label, value) => do treeError("Excpectet Node4, found Leaf3"); Leaf(label, value)  
    case Node1(label, first) => first
    case Node2(label, first, second) => first
    case _ => Leaf("a", ["b"])
  }
}


def getLabel(node: SyntaxTree): String / treeError = {
  node match {
    case Leaf(label, value) => label 
    case Node1(label, first) => label
    case Node2(label, first, second) => label
    case _ => "a"
  }
}


def getValue(leaf: SyntaxTree): List[String] / treeError = {
  leaf match {
    case Leaf(label, value) => value
    case Node1(label, first) => do treeError("Excpectet Leaf3, found Node4"); Nil()
    case Node2(label, first, second) => do treeError("Excpectet Leaf3, found Node4"); Nil()
    case _ => ["a"]
  }
} 


def getSecond(node: SyntaxTree): SyntaxTree / treeError = {
  node match {
    case Leaf(label, value) => do treeError("Excpectet Node4, found Leaf3"); Leaf(label, value) 
    case Node1(label, first) => first
    case Node2(label, first, second) => second
    case _ => Leaf("a", ["b"])
  }
}


def printTree2(node: SyntaxTree): Unit = {
  def printNode(node: SyntaxTree, indent: String): Unit = {
    node match {
      case Leaf(label, value) => println(indent ++ label ++ ": " ++ showWords(value))
      case Sentence(subjects, predicates) => 
        println(indent ++ "Sentence")
        printNode(subjects, indent ++ "  ")
        printNode(predicates, indent ++ "  ")
      case PhraseList(label, front, back) => 
        println(indent ++ "label")
        printNode(front, indent ++ "  ")
        printNode(back, indent ++ "  ")
      case ObjectLeaf2(label, prep, head, modifiers) =>
        println(indent ++ label ++ ": " ++ head ++ showWords(modifiers))
      case _ => println(indent ++ "Unknown node")
    }
  }
  printNode(node, "")
}


def printTree(node: SyntaxTree): Unit = {
  def printNode(node: SyntaxTree, indent: String): Unit = {
    node match {
      case Leaf(label, value) => println(indent ++ label ++ ": " ++ showWords(value))
      case Node1(label, first) => 
        println(indent ++ label)
        printNode(first, indent ++ "  ")
      case Node2(label, first, second) => 
        println(indent ++ label)
        printNode(first, indent ++ "  ")
        printNode(second, indent ++ "  ")
      case _ => println(indent ++ "Unknown node")
    }
  }
  printNode(node, "")
}


def main(): Unit = {
  val tree1: SyntaxTree = Node2("Sentence", Node1("NP", Leaf("Noun", ["Soweli"])), Node2("VP", Leaf("Pred", ["moli"]), Node1("NP", Leaf("Noun", ["Soweli"]))));
  val l1: List[String] = ["mi", "sona", "mute", "e", "toki", "pona"]
  val l2: List[String] = ["mama", "ona", "li", "sona", "mute", "e", "toki", "pona"]
  println("a")
}