module buildTree

import src/trees
import src/additionalLists
import src/effects



def splitSentence(sentence: List[String]): SyntaxTree = {
  var tree: SyntaxTree = Sentence(PhraseList("List", Empty(), Empty()), PhraseList("List", Empty(), Empty()))
  try {
    sentence.findAndRemoveSubjects().findAndRemovePredicates()
    return tree
  } with append { n => 
    tree = append(tree, n)
    resume(())
  } with sentenceError { msg => 
    println(msg)
    return Empty()
  }
} 


def findAndRemoveSubjects(sentence: List[String]): List[String] / {append, sentenceError} = {
  if (sentence.subjectOnlyMiSina()) {
    //println("Subject is only mi or sina")
    do append(ObjectLeaf("Subject Phrase", "", showWords(sentence.take(1)), Nil()))
    return sentence.drop(1)
  } else {
    sentence.getIndexOf("en") match {
      case Some(index) => {
        //println("found en")
        do append(ObjectLeaf("Subject Phrase", "", showWords(sentence.take(1)), sentence.slice(1, index)))
        return findAndRemoveSubjects(sentence.drop(index + 0))
        }
      case None() => {
        sentence.getIndexOf("li") match {
          case Some(index) => {
            //println("found li")
            do append(ObjectLeaf("Subject Phrase", "", showWords(sentence.take(1)), sentence.slice(1, index)))
            return sentence.drop(index + 1)
          }
          case None() => {
            //println("weird")
            return sentence
          }
        }
      }
    }
  }
}


/// TODO: Preverbs
def findAndRemovePredicates(sentence: List[String]): List[String] / {append, sentenceError} = {
  val endOfPredicate = {
    sentence.getIndexOf("li") match {
      case Some(index) => index
      case None() => sentence.size()
    }
  } 
  //println("endOfPredicate: " ++ show(endOfPredicate))
  val indexE = sentence.getIndexOf("e") match {
    case Some(index) => index
    case None() => endOfPredicate
  }
  //println("indexE: " ++ show(indexE))
  val indexPreposition = sentence.getIndexOf(["lon", "kepeken", "tawa", "tan", "sama"]) match {
    case Some(index) => index
    case None() => endOfPredicate
  }
  //println("indexPreposition: " ++ show(indexPreposition))
  val verb = VerbLeaf("Verb", [], showWords(sentence.take(1)), sentence.slice(1, indexE))
  //println("verb: " ++ showWords(sentence.take(1)) ++ " Modifiers: " ++ showWords(sentence.slice(1, indexE)))
  val objects = splitObjects(sentence.slice(indexE + 1, indexPreposition))
  val prepositions = splitPrepositions(sentence.slice(indexPreposition, endOfPredicate))
  do append(Predicate(verb, objects, prepositions))
  if(endOfPredicate == sentence.size()) {
    return []
  } 
  else {
    return findAndRemovePredicates(sentence.drop(endOfPredicate + 1))
  } 
}


def splitObjects(sentence: List[String]): SyntaxTree = {
  if (sentence.size == 0) {
    return Empty()
  }
  else {
    var tree: SyntaxTree = PhraseList("List", Empty(), Empty())
    try {
      sentence.findAndRemoveObjects()
      return tree
    } with append { n =>
      tree = appendObjects(tree, n)
      resume(())
    }
  }
}


def findAndRemoveObjects(sentence: List[String]): List[String] / {append} = {
  sentence.getIndexOf("e") match {
    case Some(index) => {
      do append(ObjectLeaf("Object Phrase", "", showWords(sentence.take(1)), sentence.slice(1, index)))
      return findAndRemoveObjects(sentence.drop(index + 1))
    }
    case None() => {
      do append(ObjectLeaf("Object Phrase", "", showWords(sentence.take(1)), sentence.drop(1)))
      return sentence
    }
  }
}


def splitPrepositions(sentence: List[String]): SyntaxTree = {
  if (sentence.size == 0) {
    return Empty()
  }
  else {
    var tree: SyntaxTree = PhraseList("List", Empty(), Empty())
    try {
      sentence.findAndRemovePrepositions()
      return tree
    } with append { n =>
      tree = appendObjects(tree, n)
      resume(())
    }
  }
}

def findAndRemovePrepositions(sentence: List[String]): List[String] / {append} = {
  sentence.drop(1).getIndexOf(["lon", "kepeken", "tawa", "tan", "sama"]) match {
    case Some(index) => {
      do append(ObjectLeaf("Preposition Phrase", showWords(sentence.take(1)), showWords(sentence.drop(1).take(1)), sentence.slice(2, index)))
      return findAndRemovePrepositions(sentence.drop(index + 1))
    }
    case None() => {
      do append(ObjectLeaf("Preposition Phrase", showWords(sentence.take(1)), showWords(sentence.drop(1).take(1)), sentence.drop(2)))
      return sentence
    }
  }
}


def subjectOnlyMiSina(sentence: List[String]): Bool = {
  sentence match {
    case Cons("mi", Cons("en", _)) => false
    case Cons("mi", notEn) => true
    case Cons("sina", Cons("en", _)) => false
    case Cons("sina", notEn) => true
    case _ => false
  }
}



def main(): Unit = {
  var t1 = splitSentence(["mama", "li", "toki", "pona", "e", "sina", "kepeken", "a", "tawa", "f", "li", "a", "e", "b", "li", "a"])
  //var t2 = splitSentence(["mama", "en", "soweli", "pimexja", "en", "as", "as", "li", "soweli", "a", "tawa", "toki", "pona"])
  /// var t3 = Sentence(PhraseList("Subject", ObjectLeaf("Subject Phrase", ["mi"]), Empty()), Empty())
  var t4 = Sentence(PhraseList("Subjects", Empty(), Empty()), PhraseList("Predicates", Empty(), Empty()))
  var t5 = Sentence(PhraseList("Subjects", Empty(), Empty()), PhraseList("Predicates", Predicate(VerbLeaf("verb", [], "a", []), Empty(), Empty()), Empty()))
  //printTree(t5)
  //printTree(append(t4, Predicate(VerbLeaf("verb", [], "a", []), Empty(), Empty())))
  printTree(t1)
}




