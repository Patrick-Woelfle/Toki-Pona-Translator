module buildTree

import src/syntaxTree
import src/additionalListFunctions
import src/effects


/// Takes a Toki Pona sentence and turns it into a syntax tree
def constructSyntaxTree(sentence: List[String]): SyntaxTree / {ambiguityVerbOnlyLi} = {
  var tree: SyntaxTree = Sentence([], [])
  try {
    sentence.findAndRemoveSubjects().findAndRemovePredicates()
    return tree
  } with append { n => 
    tree = appendToSentence(tree, n)
    resume(())
  } with sentenceError { msg => 
    println("SENTENCE ERROR: " ++ msg)
    return Empty()
  } 
}


/// Adds a node at the right place in a syntax tree
def appendToSentence(tree: SyntaxTree, node: SyntaxTree): SyntaxTree = {
  tree match {
    case Sentence(subjects, predicates) => {
      node match {
        case SubjectLeaf(head, modifiers) => {
          return Sentence(subjects.append([node]), predicates)
        }
        case Predicate(verb, objects, prepositions) => {
          return Sentence(subjects, predicates.append([node]))
        }
        case _ => return Empty()
      }
    }
    case _ => return Empty()
  }
}


/// Takes a Toki Pona sentence, finds, removes and adds them to the syntax tree
def findAndRemoveSubjects(sentence: List[String]): List[String] / { append, sentenceError } = {
  if (sentence.subjectOnlyMiOrSina()) {
    do append(SubjectLeaf(sentence.take(1), Nil()))
    return sentence.drop(1)
  }
  else {
    sentence.getIndexOf("en") match {
      case Some(index) => {
        do append(SubjectLeaf(sentence.take(1), sentence.slice(1, index)))
        return findAndRemoveSubjects(sentence.drop(index + 1))
        }
      case None() => {
        sentence.getIndexOf("li") match {
          case Some(index) => {
            do append(SubjectLeaf(sentence.take(1), sentence.slice(1, index)))
            return sentence.drop(index + 1)
          }
          case None() => {
            do append(SubjectLeaf(sentence.take(1), sentence.drop(1)))
            return []
          }
        }
      }
    }
  }
}


/// Checks if the Subject is only Mi or Sina
def subjectOnlyMiOrSina(sentence: List[String]): Bool / sentenceError = {
  sentence match {
    case Cons("mi", Cons("li", _)) => do sentenceError("If mi is subject, li is not needed"); false
    case Cons("mi", Cons("en", _)) => false
    case Cons("mi", notEn) => true
    case Cons("sina", Cons("li", _)) => do sentenceError("If sina is subject, li is not needed"); false
    case Cons("sina", Cons("en", _)) => false
    case Cons("sina", notEn) => true
    case _ => false
  }
}


// Takes a Toki Pona Sentence without the subject and finds, removes and adds the predicates to the Syntax Tree
// TODO: Verb only li
def findAndRemovePredicates(sentence: List[String]): List[String] / {append, sentenceError, ambiguityVerbOnlyLi} = {
  val endOfVerb: Int = {
    sentence.getIndexOf(["lon", "kepeken", "tawa", "tan", "sama", "li", "e"]) match {
      case Some(index) => index
      case None() => sentence.size()
    }
  }
  // TODO: Clear Ambiguity, for example alasa
  val endOfPreverbs: Int = {
    sentence.getIndexOf(["wile", "sona", "awen", "kama", "ken", "lukin"]) match {
      case Some(index) => {
        sentence match {
          case Cons(_, Cons("ala", _)) => 2
          case _ => {
            if (endOfVerb > 1) 1 
            else 0
          }
        }
      }
      case None() => 0
    }
  }
  val endOfPredicate = {
    sentence.getIndexOf("li") match {
      case Some(index) => index
      case None() => sentence.size()
    }
  } 
  val endOfObjects = {
    sentence.getIndexOf(["lon", "kepeken", "tawa", "tan", "sama", "li"]) match {
      case Some(index) => index
      case None() => endOfPredicate
    }
  }
  val objects: List[SyntaxTree] = splitObjects(sentence.slice(endOfVerb + 1, endOfObjects))
  val verb: SyntaxTree = VerbLeaf(sentence.take(endOfPreverbs), sentence.slice(endOfPreverbs, endOfPreverbs + 1), sentence.slice(endOfPreverbs + 1, endOfVerb))
  val prepositions: List[SyntaxTree]  = splitPrepositions(sentence.slice(endOfObjects, endOfPredicate))
  val predicate = {
    if (objects.size() == 0 and endOfPreverbs == 0) {
      if (do ambiguityVerbOnlyLi()) {
        Predicate(verb, objects, prepositions)
      } else {
        Predicate(Empty(), [ObjectLeaf(sentence.take(1), sentence.slice(1, endOfObjects))], prepositions)
      }
    }
    else {
      Predicate(verb, objects, prepositions)
    }
  }
  do append(predicate)
  if(endOfPredicate == sentence.size()) return []
  else return findAndRemovePredicates(sentence.drop(endOfPredicate + 1))
}


/// Takes a list of Objects split by prepositions and turns them into Prepositions Leafs
def splitPrepositions(sentence: List[String]): List[SyntaxTree] = {
  var output: List[SyntaxTree] = []
  try {
    def splitPrepositionsHelper(sentence: List[String]): Unit / append = {
      if (sentence.size == 0) {
        return ()
      }
      else {
        sentence.drop(1).getIndexOf(["lon", "kepeken", "tawa", "tan", "sama"]) match {
          case Some(index) => {
            do append(PrepositionsLeaf(sentence.take(1), sentence.slice(1, 2), sentence.slice(2, index + 1)))
            splitPrepositionsHelper(sentence.drop(index + 1))
            return ()
          }
          case None() => {
            do append(PrepositionsLeaf(sentence.take(1), sentence.slice(1, 2), sentence.drop(2)))
          }
        }
      } 
    }
    splitPrepositionsHelper(sentence)
    return output
  } with append { n => 
    output = output.append([n])
    resume(())
  }
}


/// Takes a list of objects split by "e" and turns them into Object Leafs
def splitObjects(sentence: List[String]): List[SyntaxTree] = {
    var output: List[SyntaxTree] = []
  try {
    def splitObjectsHelper(sentence: List[String]): Unit / append = {
      if (sentence.size == 0) {
        return ()
      }
      else {
        sentence.drop(1).getIndexOf("e") match {
          case Some(index) => {
            do append(ObjectLeaf(sentence.take(1), sentence.slice(1, index + 1)))
            splitObjectsHelper(sentence.drop(index + 2))
            return ()
          }
          case None() => {
            do append(ObjectLeaf(sentence.take(1), sentence.drop(1)))
          }
        }
      } 
    }
    splitObjectsHelper(sentence)
    return output
  } with append { n => 
    output = output.append([n])
    resume(())
  }
}


def main(): Unit = {
  try {
    //var t1 = constructSyntaxTree(["mi", "a", "b"])
    //var t2 = constructSyntaxTree(["sina", "li", "a", "b"])
    //var t3 = constructSyntaxTree(["a", "li", "b"])
    //var t4 = constructSyntaxTree(["a", "li", "d", "2", "e", "f", "li", "g", "lon", "i", "tawa", "i", "j"])
    //var t5 = constructSyntaxTree(["a", "li", "wile", "d", "2", "e", "g", "li", "h", "lon", "j", "li", "k"])
    //var t6 = constructSyntaxTree(["soweli", "li", "moku", "e", "moku"])
    var t7 = constructSyntaxTree(["soweli", "li", "wile", "moku", "pona", "e", "moku", "lili", "e", "kasi", "kepeken", "uta", "kepeken", "luka", "li", "moku", "e", "moku", "suli"])
    //var t8 = constructSyntaxTree(["a", "li", "d", "e", "f", "lon", "g", "li", "h"])
    printSyntaxTree(t7)
  } with ambiguityVerbOnlyLi {
    resume(true)
  }
}

