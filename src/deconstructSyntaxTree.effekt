module src/deconstructSyntaxTree

import src/syntaxTree
import src/additionalListFunctions
import src/convertSyntaxTree
import src/constructSyntaxTree
import src/effects


def deconstructSyntaxTree(tokiPonaTree: SyntaxTree): String / ambiguity[Plural] = {
  var output = ""
  var thirdPerson: Bool = true
  try {
    def deconstructSyntaxTreeHelper(index: Int, englishTree: SyntaxTree): Unit / ambiguity[Plural] = {
      englishTree match {
        case Sentence(subjects, predicates) => {
          subjects.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
          predicates.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
        }
        case SubjectLeaf(head, modifiers) => {
          modifiers.foreachIndex{ (index, x) => 
            do addToSentence(x)
          }
          head.foreachIndex{ (index, x) => 
            do addToSentence(x)
          }
        }
        case Predicate(verb, objects, prepositions) => {
          deconstructSyntaxTreeHelper(index, verb)
          objects.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
          prepositions.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
        }
        case VerbLeaf(preverb, head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          preverb.foreachIndex{ (newIndex, x) => 
            do addToSentence(x)
          }
          head.foreachIndex{ (newIndex, x) => 
            if (thirdPerson) {
              do addToSentence(x ++ "s")
            } else {
              do addToSentence(x)
            }
            
          }
          modifiers.foreachIndex{ (newIndex, x) => 
            do addToSentence(x)
          }
        }
        case ObjectLeaf(head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          val newIndex = index + 1
          modifiers.map{ x => 
            do addToSentence(x)
          }
          head.map{ x => 
            do addToSentence(x)
          }
          return ()
        }
        case PrepositionsLeaf(prep, head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          prep.map{ x => 
            do addToSentence(x)
          }
          modifiers.map{ x => 
            do addToSentence(x)
          }
          head.map{ x => 
            do addToSentence(x)
          }
          return ()
        }
        case _ => return ()
      }
    }
    val englishTree = convertSyntaxTree(tokiPonaTree)
    deconstructSyntaxTreeHelper(0, englishTree)
    return output
  } with addToSentence { x => 
    output = output ++ x ++ " "
    resume(())
  } with notThirdPersonSingular {
    thirdPerson = false
    resume(())
  }
}



def main(): Unit = {
  try {
    val sentence = deconstructSyntaxTree(constructSyntaxTree(["soweli", "pimeja", "suli", "li", "moku", "pona", "e", "jan", "ale", "e", "kili", "kepeken", "uta", "suli"]))
    //printSyntaxTree(englishTree)
    println(sentence)
  } with ambiguity[Plural] { (first, second) =>
    resume(first)
    resume(second)
  }
}