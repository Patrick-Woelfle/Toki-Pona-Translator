module src/deconstructSyntaxTree

import src/additionalListFunctions
import src/syntaxTree
import src/additionalListFunctions
import src/constructSyntaxTree
import src/effects
import src/translateWords

/// Takes a toki pona syntax tree and turns it into a sentence
def deconstructSyntaxTree(tokiPonaTree: SyntaxTree): String / { ambiguity } = {
  var output: String = ""
  var storage: String = ""
  var code: String = ""
  var thirdPerson: Bool = true
  try {
    def deconstructSyntaxTreeHelper(index: Int, englishTree: SyntaxTree): Unit / ambiguity = {
      englishTree match {
        case Sentence(subjects, predicates) => {
          subjects.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
          predicates.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
        }
        case SubjectLeaf(head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
            do notThirdPersonSingular()
          }
          modifiers.reverse.foreachIndex{ (index, x) => 
            do addToSentence(translateWord(x, Modifier(), thirdPerson))
          }
          head.foreachIndex{ (index, x) => 
            do addToSentence(translateWord(x, Subject(), thirdPerson))
          }
        }
        case Predicate(verb, objects, prepositions) => {
          if (index != 0) {
            do addToSentence("and")
          }
          verb match {
            case Empty() => do addToSentence("is")
            case _ => ()
          }
          deconstructSyntaxTreeHelper(index, verb)
          objects.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
          prepositions.foreachIndex{ (index, x) => deconstructSyntaxTreeHelper(index, x)}
          if (storage.length() != 0) do addToSentence(do release("adverbs"))
        }
        case VerbLeaf(preverb, head, modifiers) => {
          val newModifiers = modifiers.getIndexOf("not") match {
            case Some(0) => {
              if (thirdPerson) {
                do addToSentence("doesn't")
                modifiers.drop(1)
              } else {
                do addToSentence("don't")
                modifiers.drop(1)
              }
            }
            case _ => modifiers
          }
          preverb.reverse().foreachIndex{ (newIndex, x) => 
            do addToSentence(translateWord(x, Preverb(), thirdPerson))
          }
          head.foreachIndex{ (newIndex, x) => 
            if (preverb.size != 0) {
              do addToSentence(translateWord(x, Verb(), false))
            } else {
              do addToSentence(translateWord(x, Verb(), thirdPerson))
            }
            
          }
          newModifiers.reverse().foreachIndex{ (newIndex, x) => 
            do hold(translateWord(x, Adverb(), thirdPerson), "adverbs")
          }
        }
        case ObjectLeaf(head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          val newIndex = index + 1
          modifiers.reverse.map{ x => 
            do addToSentence(translateWord(x, Modifier(), thirdPerson))
          }
          head.map{ x => 
            do addToSentence(translateWord(x, Object(), thirdPerson))
          }
          return ()
        }
        case PrepositionsLeaf(prep, head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          prep.map{ x => 
            do addToSentence(translateWord(x, Preposition(), thirdPerson))
          }
          modifiers.reverse.map{ x => 
            do addToSentence(translateWord(x, Modifier(), thirdPerson))
          }
          head.map{ x => 
            do addToSentence(translateWord(x, Object(), thirdPerson))
          }
          return ()
        }
        case _ => return ()
      }
    }
    deconstructSyntaxTreeHelper(0, tokiPonaTree)
    return output
  } with addToSentence { x => 
    output = output ++ x ++ " "
    resume(())
  } with notThirdPersonSingular {
    thirdPerson = false
    resume(())
  } with hold { (storedValue, newCode) =>
    code = newCode
    storage = storage ++ storedValue
    resume(())
  } with release { (newCode) =>
    if (newCode == code) {
      val output = storage
      storage = ""
      resume(output)
    } else {
      resume("")
    }

  }
}


def main(): Unit = {
  println("a")
}