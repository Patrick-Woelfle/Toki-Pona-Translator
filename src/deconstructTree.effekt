module src/deconstructTree

import src/trees
import src/additionalLists
import src/translateSentences
import src/buildTree
import src/effects


def deconstructTree(tree: SyntaxTree): String / ambiguity[Plural] = {
  var output = ""
  try {
    def deconstructTreeHelper(index: Int, tree: SyntaxTree): Unit / ambiguity[Plural] = {
      tree match {
        case Sentence(subjects, predicates) => {
          subjects.foreachIndex{ (index, x) => deconstructTreeHelper(index, x)}
          predicates.foreachIndex{ (index, x) => deconstructTreeHelper(index, x)}
        }
        case SubjectLeaf(head, modifiers) => {
          modifiers.foreachIndex{ (index, x) => 
            do addToSentence(x)
          }
          head.foreachIndex{ (index, x) => 
            do addToSentence(x)
          }
        }
        case Predicate(verb, objects, prepositions) => {
          deconstructTreeHelper(index, verb)
          objects.foreachIndex{ (index, x) => deconstructTreeHelper(index, x)}
          prepositions.foreachIndex{ (index, x) => deconstructTreeHelper(index, x)}
        }
        case VerbLeaf(preverb, head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          preverb.foreachIndex{ (newIndex, x) => 
            do addToSentence(x)
          }
          head.foreachIndex{ (newIndex, x) => 
            do addToSentence(x ++ "s")
          }
          modifiers.foreachIndex{ (newIndex, x) => 
            do addToSentence(x)
          }
        }
        case ObjectLeaf(head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          val newIndex = index + 1
          modifiers.extraMap{ x => 
            do addToSentence(x)
          }
          head.extraMap{ x => 
            do addToSentence(x)
          }
          return ()
        }
        case PrepositionsLeaf(prep, head, modifiers) => {
          if (index != 0) {
            do addToSentence("and")
          }
          prep.extraMap{ x => 
            do addToSentence(x)
          }
          modifiers.extraMap{ x => 
            do addToSentence(x)
          }
          head.extraMap{ x => 
            do addToSentence(x)
          }
          return ()
        }
        case _ => return ()
      }
    }
    deconstructTreeHelper(0, tree)
    return output
  } with addToSentence { x => 
    output = output ++ x ++ " "
    resume(())
  }
}



def main(): Unit = {
  try {
    val tree = traverseTree(splitSentence(["soweli", "pimeja", "suli", "li", "moku", "pona", "e", "jan", "ale", "e", "kili", "kepeken", "uta", "suli"]))
    //printTree(tree)
    println(deconstructTree(tree))
  } with ambiguity[Plural] { (first, second) =>
    resume(first)
    resume(second)
  }

}