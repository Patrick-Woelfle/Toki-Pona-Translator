module translateSentences


import src/trees
import src/additionalLists
import src/buildTree
import src/effects
import src/translateWords


/// Translates Toki Pona Syntax Tree into English Syntax Tree
def traverseTree(tree: SyntaxTree): SyntaxTree = {
  var firstOrSecondPerson: Bool = false
  var subjectFound: Bool = false
  try {
    tree match {
      case Node2(label, first, second) => {
        Node2(label, traverseTree(first), traverseTree(second))
      }
      case Node1(label, first) => {
        Node1(label, traverseTree(first))
      }
      case Leaf(label, value) => {
        label match {
          // case "Subject Phrase" => Leaf(label, translateSubjectPhrase(value))
          case "Noun Phrase" => Leaf(label, translateNounPhrase(value))
          case "Verb Phrase" => Leaf(label, translateVerbPhrase(value))
          case _ => Leaf(label, value)
        }
      }
      case _ => {
        Empty()
      }
    }
  } with additionalContext { context =>
    context match {
      case "firstOrSecondPerson" => firstOrSecondPerson = true
      case "subjectTranslated" => subjectFound = true
      case _ => ()
    }
    resume(())
  }
}


/// Depricated
def translateSubjectPhrase(subjectPhrase: List[String]): List[String] / additionalContext = {
  if (subjectPhrase.size() == 1) {
    subjectPhrase.headOption() match {
      case Some("mi") => {
        do additionalContext("firstOrSecondPerson");
        <>
      }
      case Some("sina") => {
        do additionalContext("firstOrSecondPerson");
        <>
      }
      case Some(word) => {
        <>
      }
      case None() => []
    }
  }
  else return ["a"]
}


/// Translates Toki Pona Noun Phrase
/// TODO: Error Handling
def translateNounPhrase(nounPhrase: List[String]): List[String] / additionalContext = {
  try {
    if (nounPhrase.size() == 1) {
      return [translate(nounPhrase.get(0), "noun")]
    } else {
      var output: List[String] = nounPhrase.drop(1).reverse().extraMap() { x =>
        translate(x, "adjectiv")
      }
      /// Checks for Pronouns, as they need to be covered Seperatly
      if (nounPhrase.contains("mi")) {
        output = output.remove("my")
        output = output.insert(0, "my")
      } else if (nounPhrase.contains("sina")) {
        output = output.remove("sina")
        output = output.insert(0, "your")
      } else if (nounPhrase.contains("ona")) {
        output = output.remove("ona")
        output = output.insert(0, "their")
      }
      return output.insert(nounPhrase.size(), translate(nounPhrase.get(0), "noun"))
    }
  } with Exception[OutOfBounds] {
    def raise(OutOfBounds: OutOfBounds, msg: String) = {
      println(msg)
      return []
    }
  }
}



// Translates Toki Pona Verb Phrase
// TODO: Error Handling
def translateVerbPhrase(verbPhrase: List[String]): List[String] / additionalContext = {
  try {
    if (verbPhrase.size() == 1) {
      return [translate(verbPhrase.get(0), "verb")]
    } else {
      verbPhrase.drop(1).extraMap() { x =>
        translate(x, "adverb")
      }.insert(0, translate(verbPhrase.get(0), "verb"))
    }
  } with Exception[OutOfBounds] {
    def raise(OutOfBounds: OutOfBounds, msg: String) = {
      println(msg)
      return []
    }
  }
}





def main(): Unit = {
  val l1: List[String] = ["mi", "moku", "e", "moku"]
  val l2: List[String] = ["mama", "ona", "li", "sona", "mute", "e", "toki", "pona"]
  printTree(traverseTree(splitSentence(l2)))
}