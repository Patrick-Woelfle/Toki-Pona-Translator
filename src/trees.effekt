module trees // must be named same as the file!

import src/additionalLists


effect treeError(message: String): Unit


/// TODO: Switch Strings to Enumerations
type SyntaxTree {
  Empty();
  Value(value: String);
  Leaf(label: String, value: List[String]);
  Node1(label: String, first: SyntaxTree);
  Node2(label: String, first: SyntaxTree, second: SyntaxTree);

  Sentence(subPhrases: SyntaxTree, predPphrases: SyntaxTree, prepPhrases: SyntaxTree);
  SubjectPhrases(subjectPhrase: SyntaxTree, subjectPhrases: SyntaxTree);
  PredPhrases(predPhrase: SyntaxTree, predPhrases: SyntaxTree);
  PrepPhrases(pprepPhrase: SyntaxTree, prepPhrases: SyntaxTree);
  SubjectPhrase(head: String, modifiers: List[String])
  PredPhrase(verbPhrase: SyntaxTree, objectPhrase: SyntaxTree)
  PrepPhrase(preposition: String, objectPhrase: SyntaxTree)
  VerbPhrase(head: String, modifiers: List[String])
  ObjectPhrase(head: String, modifiers: List[String])
  Phrase(label: String, head: String, modifiers: List[String])
}


def append(tree: SyntaxTree, node: SyntaxTree): SyntaxTree = {
  try {
    tree match {
      case Sentence(subjectPhrases, predPhrases, prepPhrases) => {
        node match {
          case SubjectPhrase(head, modifiers) => <>
          case PredPhrase(verbPhrase, objectPhrase) => <>
          case VerbPhrase(head, modifiers) => <>
          case ObjectPhrase(head, modifiers) => <>
          case _ => <>
        }
      }
      case _ => <>
    }
  } with treeError { msg =>
    println(msg)
    return Empty()
  }
}


def getfirst(node: SyntaxTree): SyntaxTree / treeError= {
  node match {
    case Leaf(label, value) => do treeError("Excpectet Node4, found Leaf"); Leaf(label, value)  
    case Node1(label, first) => first
    case Node2(label, first, second) => first
    case _ => Leaf("a", ["b"])
  }
}


def getLabel(node: SyntaxTree): String / treeError = {
  node match {
    case Leaf(label, value) => label 
    case Node1(label, first) => label
    case Node2(label, first, second) => label
    case _ => "a"
  }
}


def getValue(leaf: SyntaxTree): List[String] / treeError = {
  leaf match {
    case Leaf(label, value) => value
    case Node1(label, first) => do treeError("Excpectet Leaf, found Node4"); Nil()
    case Node2(label, first, second) => do treeError("Excpectet Leaf, found Node4"); Nil()
    case _ => ["a"]
  }
} 


def getSecond(node: SyntaxTree): SyntaxTree / treeError = {
  node match {
    case Leaf(label, value) => do treeError("Excpectet Node4, found Leaf"); Leaf(label, value) 
    case Node1(label, first) => first
    case Node2(label, first, second) => second
    case _ => Leaf("a", ["b"])
  }
}


def printTree(node: SyntaxTree): Unit = {
  def printNode(node: SyntaxTree, indent: String): Unit = {
    node match {
      case Leaf(label, value) => println(indent ++ label ++ ": " ++ showWords(value))
      case Node1(label, first) => 
        println(indent ++ label)
        printNode(first, indent ++ "  ")
      case Node2(label, first, second) => 
        println(indent ++ label)
        printNode(first, indent ++ "  ")
        printNode(second, indent ++ "  ")
      case _ => println(indent ++ "Unknown node")
    }
  }
  printNode(node, "")
}


def main(): Unit = {
  val tree1: SyntaxTree = Node2("Sentence", Node1("NP", Leaf("Noun", ["Soweli"])), Node2("VP", Leaf("Pred", ["moli"]), Node1("NP", Leaf("Noun", ["Soweli"]))));
  val l1: List[String] = ["mi", "sona", "mute", "e", "toki", "pona"]
  val l2: List[String] = ["mama", "ona", "li", "sona", "mute", "e", "toki", "pona"]
  println("a")
  printTree(tree1)
}